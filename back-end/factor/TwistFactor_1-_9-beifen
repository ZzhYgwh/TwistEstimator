
#pragma once

#include <ceres/ceres.h>

#include "spline/spline_segment.h"
#include "utils/parameter_struct.h"

#include "split_spline_view.h"

#include "event_flow_detector/event_flow_detector.h"

#include "DebugFile.h"

#include <iomanip>  // for std::setprecision(6)

#include <Eigen/Core>
#include <Eigen/Dense>

// #include "DebugFile.cpp"

// #include "visual_odometry/integration_base.h"

// 构建反对称矩阵
// 特殊给2D 像素点使用
Eigen::Matrix3d Skew(const cv::Point2d& vec) {
    Eigen::Matrix3d result;
    result << 0, -1.0, vec.y, 1.0, 0, -vec.x, -vec.y, vec.x, 0;
    return result;
}

// 给3D Vector使用
Eigen::Matrix3d Skew(const Eigen::Vector3d& vec) {
    Eigen::Matrix3d skewMat;
    skewMat <<  0,       -vec(2),  vec(1),
                vec(2),  0,       -vec(0),
               -vec(1),  vec(0),  0;
    return skewMat;
}



// HAO TODO: 由于耦合关系,因此需要构建联合因子
/*
class TwistFactor : public ceres::CostFunction, SplitSpineView{
public:
  using SO3View = So3SplineView;
  using R3View = RdSplineView;
  using SplitView = SplitSpineView;

  using Vec3d = Eigen::Matrix<double, 3, 1>;
  using Vec6d = Eigen::Matrix<double, 6, 1>;
  using Mat3d = Eigen::Matrix<double, 3, 3>;
  using SO3d = Sophus::SO3<double>;

  TwistFactor(int64_t time_ns, const Eigen::Vector3d& pt, 
            const double& doppler, const Eigen::Matrix3d& R_e_r,
            const SplineMeta<SplineOrder>& spline_segment_meta,
            double weight)// const Vec6d& info_vec)
      : time_ns_(time_ns),
        pt_(pt), doppler_(doppler),
        spline_meta_(spline_segment_meta),
        weight_(weight)
        // info_vec_(info_vec) 
        {
          set_num_residuals(1);           // 定义残差值的大小(doppler速度残差)

          size_t knot_num = spline_meta_.NumParameters();

          // TODO: 需要提供采样曲线的多普勒速度和偏执
          // for (size_t i = 0; i < knot_num; ++i) {             
          //   mutable_parameter_block_sizes()->push_back(4);
          // }
          for (size_t i = 0; i < knot_num; ++i) {
            mutable_parameter_block_sizes()->push_back(3);
          }

          mutable_parameter_block_sizes()->push_back(3);  // linear bias

          // mutable_parameter_block_sizes()->push_back(3);  // angular bias

          // mutable_parameter_block_sizes()->push_back(1);  // time_offset 雷达时间作为系统时间,不存在时间偏移
        }

   virtual bool Evaluate(double const* const* parameters, double* residuals,
                        double** jacobians) const {
    // typename SO3View::JacobianStruct J_rot;
    // typename SO3View::JacobianStruct J_rot_a;
    typename R3View::JacobianStruct J_v;

    // 解析状态参数 parameters
    size_t knot_num = this->spline_meta_.NumParameters();               // 前 knot_num 是位置控制点 在113,120行可以计算
    LOG(ERROR) << "knot_num = " << knot_num << std::endl;
    Eigen::Map<Vec3d const> linear_bias(parameters[knot_num]);          // 速度偏置
    // Eigen::Map<Vec3d const> angular_bias(parameters[knot_num + 1]);  // 角速度偏置

    // double time_offset_in_ns = parameters[Knot_offset + 2][0];
    int64_t t_corrected = time_ns_; //  + (int64_t)time_offset_in_ns;

    // double u;
    // spline_meta_.ComputeSplineIndex(t_corrected, 0, u);

    // 估计的速度
    Eigen::Vector3d gyro_, vel_;
    if (jacobians){
      // gyro_ = SO3View::VelocityBody(t_corrected,
      //                               spline_meta_.segments.at(0),
      //                               parameters + R_offset[0], &J_w);
      vel_ = R3View::velocity(t_corrected,
                              spline_meta_.segments.at(0),
                              parameters, &J_v);
    }else{
      // gyro_ = SO3View::VelocityBody(t_corrected,
      //                               spline_meta_.segments.at(0),
      //                               parameters + R_offset[0], nullptr);
      vel_ = R3View::velocity(t_corrected,
                              spline_meta_.segments.at(0),
                              parameters, nullptr);
    }

    LOG(ERROR) << "Interpolation velocity = " << vel_.transpose() << std::endl;

    residuals[0] = weight_ * (doppler_ - pt_.normalized().transpose() * (vel_ + linear_bias));

    LOG(ERROR) << "Velocity residuals = " << residuals[0] << std::endl;

    // 速度雅可比 J_v_d_
    Eigen::Vector3d J_v_d_ = - pt_.normalized();
    // 偏置雅可比 J_v_b_  
    Eigen::Vector3d J_v_b_ = - pt_.normalized();

    /// Rotation control point // HAO TODO: 修改这个doppler无法纠正旋转控制点
    // for (size_t i = 0; i < knot_num; i++) {
    //   size_t idx = i;
    //   if (jacobians[idx]) {
    //     Eigen::Map<Eigen::Matrix<double, 1, 4, Eigen::RowMajor>> jac_kont_R(
    //         jacobians[idx]);
    //     jac_kont_R.setZero();

    //     /// 1*3 3*3
    //     jac_kont_R.block<1, 3>(0, 0) = J_w.d_val_d_knot[i];
    //     jac_kont_R = (weight_ * jac_kont_R).eval();
    //   }
    // }

    /// position control point
    for (size_t i = 0; i < knot_num; i++) {
      size_t idx = i;   // [0, knot_num - 1]
      if (jacobians[idx]) {
        Eigen::Map<Eigen::Matrix<double, 1, 3, Eigen::RowMajor>> jac_kont_p(
            jacobians[idx]);
        jac_kont_p.setZero();

        /// 1*1 1*3
        jac_kont_p =  J_v_d_ * J_v.d_val_d_knot[i]; // TODO:
        jac_kont_p = (weight_ * jac_kont_p).eval();
      }
    }

    // [3] velocity_bias 的雅可比
    Eigen::Map<Eigen::Matrix<double, 1, 3>> J_velocity_bias_(jacobians[knot_num]);
    J_velocity_bias_.setZero();
    J_velocity_bias_ = J_v_b_.transpose();

    // [4] timeoffset 本身无偏置,因此不用加入
    // Eigen::Map<Eigen::Matrix<double, 1, 3>> J_timeoffset_(jacobians[knot_num + 2]);
    // J_timeoffset_.setZero();
    // J_timeoffset_ = J_v_b_;    

    return true;

  }

private:
    int64_t time_ns_;
    Eigen::Vector3d pt_;
    SplineMeta<SplineOrder> spline_meta_;
    // Vec6d info_vec_;

    //TODO: gravity is not necessary
    // Eigen::Vector3d gravity;
    double doppler_;
    double weight_;

    // Eigen::Vector3d J_v_d_;
    // Eigen::Vector3d J_v_b_;
};

*/

/*
// HAO TODO: 以雷达的时间为准
class DopplerFactor : public ceres::CostFunction, SplitSpineView{
public:
  using SO3View = So3SplineView;
  using R3View = RdSplineView;
  using SplitView = SplitSpineView;

  using Vec3d = Eigen::Matrix<double, 3, 1>;
  using Vec6d = Eigen::Matrix<double, 6, 1>;
  using Mat3d = Eigen::Matrix<double, 3, 3>;
  using SO3d = Sophus::SO3<double>;

  DopplerFactor(int64_t time_ns, const Eigen::Vector3d& pt, 
            const double& doppler, const Eigen::Matrix3d& R_e_r,
            const SplineMeta<SplineOrder>& spline_segment_meta,
            double weight)// const Vec6d& info_vec)
      : time_ns_(time_ns),
        pt_(pt), doppler_(doppler),
        spline_meta_(spline_segment_meta),
        weight_(weight)
        // info_vec_(info_vec) 
        {
          set_num_residuals(1);           // 定义残差值的大小(doppler速度残差)

          size_t knot_num = spline_meta_.NumParameters();

          // TODO: 需要提供采样曲线的多普勒速度和偏执
          // for (size_t i = 0; i < knot_num; ++i) {             
          //   mutable_parameter_block_sizes()->push_back(4);
          // }
          for (size_t i = 0; i < knot_num; ++i) {
            mutable_parameter_block_sizes()->push_back(3);
          }

          mutable_parameter_block_sizes()->push_back(3);  // linear bias

          // mutable_parameter_block_sizes()->push_back(3);  // angular bias

          // mutable_parameter_block_sizes()->push_back(1);  // time_offset 雷达时间作为系统时间,不存在时间偏移
        }

   virtual bool Evaluate(double const* const* parameters, double* residuals,
                        double** jacobians) const {
    // typename SO3View::JacobianStruct J_rot;
    // typename SO3View::JacobianStruct J_rot_a;
    typename R3View::JacobianStruct J_v;

    // 解析状态参数 parameters
    size_t knot_num = this->spline_meta_.NumParameters();               // 前 knot_num 是位置控制点 在113,120行可以计算
    LOG(ERROR) << "knot_num = " << knot_num << std::endl;
    Eigen::Map<Vec3d const> linear_bias(parameters[knot_num]);          // 速度偏置
    // Eigen::Map<Vec3d const> angular_bias(parameters[knot_num + 1]);  // 角速度偏置

    // double time_offset_in_ns = parameters[Knot_offset + 2][0];
    int64_t t_corrected = time_ns_; //  + (int64_t)time_offset_in_ns;

    // double u;
    // spline_meta_.ComputeSplineIndex(t_corrected, 0, u);

    // 估计的速度
    Eigen::Vector3d gyro_, vel_;
    if (jacobians){
      // gyro_ = SO3View::VelocityBody(t_corrected,
      //                               spline_meta_.segments.at(0),
      //                               parameters + R_offset[0], &J_w);
      vel_ = R3View::velocity(t_corrected,
                              spline_meta_.segments.at(0),
                              parameters, &J_v);
    }else{
      // gyro_ = SO3View::VelocityBody(t_corrected,
      //                               spline_meta_.segments.at(0),
      //                               parameters + R_offset[0], nullptr);
      vel_ = R3View::velocity(t_corrected,
                              spline_meta_.segments.at(0),
                              parameters, nullptr);
    }

    LOG(ERROR) << "Interpolation velocity = " << vel_.transpose() << std::endl;

    residuals[0] = weight_ * (doppler_ - pt_.normalized().transpose() * (vel_ + linear_bias));

    LOG(ERROR) << "Velocity residuals = " << residuals[0] << std::endl;

    // 速度雅可比 J_v_d_
    Eigen::Vector3d J_v_d_ = - pt_.normalized();
    // 偏置雅可比 J_v_b_  
    Eigen::Vector3d J_v_b_ = - pt_.normalized();

    /// Rotation control point // HAO TODO: 修改这个doppler无法纠正旋转控制点
    // for (size_t i = 0; i < knot_num; i++) {
    //   size_t idx = i;
    //   if (jacobians[idx]) {
    //     Eigen::Map<Eigen::Matrix<double, 1, 4, Eigen::RowMajor>> jac_kont_R(
    //         jacobians[idx]);
    //     jac_kont_R.setZero();

    //     /// 1*3 3*3
    //     jac_kont_R.block<1, 3>(0, 0) = J_w.d_val_d_knot[i];
    //     jac_kont_R = (weight_ * jac_kont_R).eval();
    //   }
    // }

    /// position control point
    for (size_t i = 0; i < knot_num; i++) {
      size_t idx = i;   // [0, knot_num - 1]
      if (jacobians[idx]) {
        Eigen::Map<Eigen::Matrix<double, 1, 3, Eigen::RowMajor>> jac_kont_p(
            jacobians[idx]);
        jac_kont_p.setZero();

        /// 1*1 1*3
        jac_kont_p =  J_v_d_ * J_v.d_val_d_knot[i]; // TODO:
        jac_kont_p = (weight_ * jac_kont_p).eval();
      }
    }

    // [3] velocity_bias 的雅可比
    Eigen::Map<Eigen::Matrix<double, 1, 3>> J_velocity_bias_(jacobians[knot_num]);
    J_velocity_bias_.setZero();
    J_velocity_bias_ = J_v_b_.transpose();

    // [4] timeoffset 本身无偏置,因此不用加入
    // Eigen::Map<Eigen::Matrix<double, 1, 3>> J_timeoffset_(jacobians[knot_num + 2]);
    // J_timeoffset_.setZero();
    // J_timeoffset_ = J_v_b_;    

    return true;

  }

private:
    int64_t time_ns_;
    Eigen::Vector3d pt_;
    SplineMeta<SplineOrder> spline_meta_;
    // Vec6d info_vec_;

    //TODO: gravity is not necessary
    // Eigen::Vector3d gravity;
    double doppler_;
    double weight_;

    // Eigen::Vector3d J_v_d_;
    // Eigen::Vector3d J_v_b_;
};
*/

/*
class EventAgularFactor : public ceres::CostFunction, SplitSpineView{
 public:
  using SO3View = So3SplineView;
  using R3View = RdSplineView;
  using SplitView = SplitSpineView;

  using Vec3d = Eigen::Matrix<double, 3, 1>;
  using Vec6d = Eigen::Matrix<double, 6, 1>;
  using Mat3d = Eigen::Matrix<double, 3, 3>;
  using Quatd = Eigen::Quaterniond;
  using SO3d = Sophus::SO3<double>;

  EventAgularFactor(int64_t time_ns, const cv::Point2d pt, const event_flow_velocity flow, 
            const Eigen::Vector3d doppler_velocity,
            const Eigen::Quaterniond & q_e_r, const Eigen::Vector3d& t_e_r,
            const SplineMeta<SplineOrder>& spline_segment_meta, Eigen::Vector3d& angular_bias,
            double weight) // const Vec6d& info_vec)
      : time_ns_(time_ns),
        pt_(pt), doppler_velocity_(doppler_velocity),
        q_e_r(q_e_r), t_e_r(t_e_r),
        spline_meta_(spline_segment_meta),
        angular_bias(angular_bias),
        lock_extrincs(true),      // HAO TODO: 暂时不优化外参
        weight_(weight)

    // info_vec_(info_vec) 
    {
      set_num_residuals(1);           // 定义残差值的大小(事件角速度残差)

      flow_ << flow.x, flow.y, 0;

      size_t knot_num = this->spline_meta_.NumParameters();

      // TODO: 需要提供采样曲线的多普勒速度和偏执                   
      for (size_t i = 0; i < knot_num; ++i) {             
        mutable_parameter_block_sizes()->push_back(4);   // rotation
      }
      // for (size_t i = 0; i < knot_num; ++i) {
      //   mutable_parameter_block_sizes()->push_back(3);
      // }

      mutable_parameter_block_sizes()->push_back(3);    // omega bias
      
      // if(!optition.lock_extrincs)

      if(! lock_extrincs)
      {
        mutable_parameter_block_sizes()->push_back(4);  // q_e_r
        mutable_parameter_block_sizes()->push_back(3);  // t_e_r
      }
      mutable_parameter_block_sizes()->push_back(1);  // time_offset 事件时间和雷达时间的偏移
    }

   virtual bool Evaluate(double const* const* parameters, double* residuals,
                        double** jacobians) const {
      typename SO3View::JacobianStruct J_w;
      typename R3View::JacobianStruct J_v;
      
      size_t knot_num = spline_meta_.NumParameters();
      Eigen::Map<Vec3d const> omega_bias(parameters[knot_num]);

      // Eigen::Map<Mat3d const> T_R_e_r(parameters[knot_num + 1]);

      Eigen::Map<Quatd const> q_e_r(parameters[knot_num + 1]);
      Eigen::Map<Vec3d const> T_t_e_r(parameters[knot_num + 2]);

      double time_offset_in_ns = parameters[knot_num + 3][0];

      int64_t t_corrected = time_ns_ + (int64_t)time_offset_in_ns;

      // 估计的速度 
      // Eigen::Vector3d gyro_, vel_, rot_accel, accel_r3;
      Eigen::Vector3d gyro_, rot_accel;
      if (jacobians){
        gyro_ = SO3View::VelocityBody(t_corrected,
                                            spline_meta_.segments.at(0),
                                            parameters, &J_w);
        // vel_ = R3View::velocity(t_corrected,
        //                               spline_meta_.segments.at(0),
        //                               parameters + knot_num, &J_v);   
        rot_accel = SO3View::accelerationBody(t_corrected,  
                                              spline_meta_.segments.at(0), 
                                              parameters);
        // accel_r3 = R3View::acceleration(t_corrected,
        //                             spline_meta_.segments.at(0),
        //                             parameters + knot_num, nullptr);   // &J_a
      }else{
        gyro_ = SO3View::VelocityBody(t_corrected,
                                      spline_meta_.segments.at(0),
                                      parameters, nullptr);
        // vel_ = R3View::velocity(t_corrected,
        //                               spline_meta_.segments.at(0),
        //                               parameters + knot_num, nullptr);

        rot_accel = SO3View::accelerationBody(t_corrected,  
                                              spline_meta_.segments.at(0), 
                                              parameters);

        // accel_r3 = R3View::acceleration(t_corrected,
        //                             spline_meta_.segments.at(0),
        //                             parameters + knot_num, nullptr);
      }

      // Conversion vel
      Eigen::Matrix3d R_e_r = q_e_r.toRotationMatrix();   
      Eigen::Vector3d pre_vec = Skew(pt_) * R_e_r * ((gyro_ + angular_bias).cross(t_e_r) + doppler_velocity_); // use it add tranpose()
      Eigen::Vector3d post_vec = (flow_ +  Skew(pt_) * R_e_r * (gyro_ + angular_bias));

      // 残差计算
      residuals[0] =  pre_vec.transpose() * post_vec;
      residuals[0] *= weight_;
     
      // TODO: 补充雅可比
      if (jacobians) {
          // [1] gyro_ 的雅可比
          Eigen::Matrix3d J_gyro_pre_ = (Skew(pt_) * R_e_r * Skew(t_e_r));
          Eigen::Matrix3d J_gyro_post_ = Skew(pt_) * R_e_r;

          ///[step1-2] jacobians of control points
          /// Rotation control point
          for (size_t i = 0; i < knot_num; i++) {
            size_t idx = i;
            if (jacobians[idx]) {
              Eigen::Map<Eigen::Matrix<double, 1, 4, Eigen::RowMajor>> jac_kont_R(
                  jacobians[idx]);
              jac_kont_R.setZero();

              /// 1*3 3*3
              jac_kont_R.block<1, 3>(0, 0) =
                  (J_gyro_pre_.transpose() * J_w.d_val_d_knot[i] * post_vec).transpose()
                  + pre_vec.transpose() * J_gyro_post_ * J_w.d_val_d_knot[i];
              jac_kont_R = (weight_ * jac_kont_R).eval();
            }
          }

          // [2] doppler_velocity 的雅可比
          // J_vel_ = (flow - Skew(pt_) * R_e_r * (gyro_ + angular_bias)).transpose() * Skew(pt_) * R_e_r;

          // /// position control point
          // for (size_t i = 0; i < knot_num; i++) {
          //   size_t idx = knot_num + i;
          //   if (jacobians[idx]) {
          //     Eigen::Map<Eigen::Matrix<double, 1, 3, Eigen::RowMajor>> jac_kont_p(
          //         jacobians[idx]);
          //     jac_kont_p.setZero();

          //     /// 1*1 1*3
          //     jac_kont_p = J_v.d_val_d_knot[i] * J_vel_;
          //     jac_kont_p = (weight_ * jac_kont_p).eval();
          //   }
          // }

          // [3] angular_bias 的雅可比
          Eigen::Map<Eigen::Matrix<double, 1, 3>> J_angular_bias_(jacobians[knot_num]);
          J_angular_bias_.setZero();
          J_angular_bias_ = (J_gyro_pre_.transpose() * post_vec).transpose() + pre_vec.transpose() * Skew(pt_) * R_e_r;

          // if(!optition.lock_extrincs)
          // {
              // 雅可比矩阵
              // Eigen::Matrix<double, 1, 4> J;

          // 对于旋转部分的雅可比
          /* 推导过程
          residuals[0] = (Skew(pt_) * R_e_r * (gyro_.cross(t_e_r) + vel_)).transpose() * 
                              (flow_ - Skew(pt_) * R_e_r * (gyro_ + angular_bias))
          A = (Skew(pt_) * R_e_r * (gyro_.cross(t_e_r) + vel_)).transpose()
          B = (flow_ - Skew(pt_) * R_e_r * (gyro_ + angular_bias))
          dA = Skew(pt_) * dR_theta * R_e_r * (gyro_.cross(t_e_r) + vel_)).transpose()
          dA.transpose() = Skew(pt_) * dR_theta * R_e_r * (gyro_.cross(t_e_r) + vel_))

          residuals[0] / R_e_r = ???
          
          // if(!optition.lock_extrincs)

          if(! lock_extrincs)
          {
            Eigen::Map<Eigen::Matrix<double, 1, 3>> J_R(jacobians[knot_num + 1]);
            Eigen::Map<Eigen::Matrix<double, 1, 3>> J_t(jacobians[knot_num + 2]);
            Eigen::MatrixXd J_pre_R = - (Skew(pt_) * Skew(R_e_r * ((gyro_ + angular_bias).cross(t_e_r) + doppler_velocity_))).transpose();
            
            Eigen::MatrixXd J_pre_t = - (Skew(pt_) * R_e_r * Skew(gyro_ + angular_bias)).transpose();

            Eigen::MatrixXd J_post_R = - (Skew(pt_) * Skew(R_e_r * ((gyro_ + angular_bias).cross(t_e_r) + doppler_velocity_)));

            J_R = (J_pre_R * post_vec + pre_vec * J_post_R).transpose();
            J_t = (J_pre_t * post_vec).transpose();
          }
          
          Eigen::Map<Eigen::VectorXd> J_t_offset(jacobians[knot_num + 3], 3);  // Assuming a 3D vector
          J_t_offset.setZero();

          J_t_offset = (Skew(pt_) * R_e_r * t_e_r.cross(rot_accel)).transpose() * post_vec 
                        + pre_vec.transpose() * (Skew(pt_) * R_e_r * rot_accel);

          J_t_offset *= 1e-9 * weight_;

      }
    }

private:
    int64_t time_ns_;
    cv::Point2d pt_;
    Eigen::Vector3d flow_;
    Eigen::Vector3d doppler_velocity_;
    Eigen::Quaterniond q_e_r;
    Eigen::Vector3d t_e_r;
    SplineMeta<SplineOrder> spline_meta_;
    // Vec6d info_vec_;
    Eigen::Vector3d angular_bias;
    Eigen::Vector3d gravity;
    bool lock_extrincs;
    double weight_;
};
*/


// 在这个源文件中定义并初始化 debug_ceres
// const std::string debug_ceres_path = "/home/hao/Desktop/ceres_solver.debug";
// Ceres_Debug_File debug_ceres(debug_ceres_path);  // 定义并初始化全局变量
// Ceres_Debug_File debug_ceres(debug_ceres_path);


std::string Output(const Eigen::RowVectorXd& vec) {
    std::stringstream ss;
    ss << "[";
    for (int i = 0; i < vec.size(); ++i) {
        ss << vec(i);
        if (i < vec.size() - 1) {
            ss << ", ";  // 在元素之间加逗号
        }
    }
    ss << "]";
    return ss.str();
}

std::string Output_M(const Eigen::MatrixXd& mat) {
    std::stringstream ss;
    ss << "[";
    for (int i = 0; i < mat.rows(); ++i) {
        ss << "[";
        for (int j = 0; j < mat.cols(); ++j) {
            ss << mat(i, j);
            if (j < mat.cols() - 1) {
                ss << ", ";  // 在元素之间加逗号
            }
        }
        ss << "]";
        if (i < mat.rows() - 1) {
            ss << ",\n ";  // 在每一行之间换行
        }
    }
    ss << "]";
    return ss.str();
}

std::string Output_double(const double& val) {
    std::stringstream ss;
    ss << "[";
    // ss << std::fixed << std::setprecision(6) << val;  // 控制精度为6位小数（根据需求调整）
    ss << val;  // 控制精度为6位小数（根据需求调整）
    ss << "]";
    return ss.str();
}


// HAO TODO: 以雷达的时间为准
class DopplerFactor : public ceres::CostFunction, SplitSpineView{
public:
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
  using SO3View = So3SplineView;
  using R3View = RdSplineView;
  using SplitView = SplitSpineView;

  using Vec3d = Eigen::Matrix<double, 3, 1>;
  using Vec6d = Eigen::Matrix<double, 6, 1>;
  using Mat3d = Eigen::Matrix<double, 3, 3>;
  using SO3d = Sophus::SO3<double>;

  DopplerFactor(int64_t time_ns, const Eigen::Vector3d& pt, 
            const double& doppler, const Eigen::Matrix3d& R_e_r,
            const SplineMeta<SplineOrder>& spline_segment_meta,
            double weight)// const Vec6d& info_vec)
      : time_ns_(time_ns),
        pt_(pt), doppler_(doppler),
        spline_meta_(spline_segment_meta),
        weight_(weight)
        // info_vec_(info_vec) 
        {
          set_num_residuals(1);           // 定义残差值的大小(doppler速度残差)

          size_t knot_num = spline_meta_.NumParameters();

          std::cout << "knot_num = " << knot_num << std::endl;

          // TODO: 需要提供采样曲线的多普勒速度和偏执
          for (size_t i = 0; i < knot_num; ++i) {             
            mutable_parameter_block_sizes()->push_back(4);    // HAO TODO:
          }
          for (size_t i = 0; i < knot_num; ++i) {
            mutable_parameter_block_sizes()->push_back(3);
          }

          mutable_parameter_block_sizes()->push_back(3);  // linear bias

          // mutable_parameter_block_sizes()->push_back(3);  // angular bias

          // mutable_parameter_block_sizes()->push_back(1);  // time_offset 雷达时间作为系统时间,不存在时间偏移
        }

   virtual bool Evaluate(double const* const* parameters, double* residuals,
                        double** jacobians) const {
    typename SO3View::JacobianStruct J_R;
    // typename SO3View::JacobianStruct J_rot_a;
    typename R3View::JacobianStruct J_v;

    LOG(ERROR) << "Evaluate DopplerFactor " << std::endl;

    // 解析状态参数 parameters
    int knot_num = this->spline_meta_.NumParameters();               // 前 knot_num 是位置控制点 在113,120行可以计算

    // LOG(ERROR) << "knot_num = " << knot_num << std::endl;
    // LOG(ERROR) << "2 * knot_num - 1 = " << 2 * knot_num - 1 << std::endl;
    // LOG(ERROR) << "J_velocity_rot_ = " << ((jacobians[2 * knot_num - 1] == nullptr)? "nullptr": "exist") << std::endl;

    // double time_offset_in_ns = parameters[Knot_offset + 2][0];
    int64_t t_corrected = time_ns_; //  + (int64_t)time_offset_in_ns;


    // 估计的速度
    Eigen::Vector3d gyro_, v_inG;
    SO3d S_ItoG;
    if (jacobians){
      // gyro_ = SO3View::VelocityBody(t_corrected,
      //                               spline_meta_.segments.at(0),
      //                               parameters + R_offset[0], &J_w);

      LOG(ERROR) << std::setprecision(20) << " t_corrected = " << t_corrected << std::endl;

      // HAO TODO:
      S_ItoG = SO3View::EvaluateRp(t_corrected, spline_meta_.segments.at(0),
                              parameters, &J_R);

      LOG(ERROR) << "first J_R.start_idx = " <<  J_R.start_idx << std::endl;

      v_inG = R3View::velocity(t_corrected,
                              spline_meta_.segments.at(0),
                              parameters + knot_num, &J_v);
    }else{
      // gyro_ = SO3View::VelocityBody(t_corrected,
      //                               spline_meta_.segments.at(0),
      //                               parameters + R_offset[0], nullptr);

      // HAO TODO:
      S_ItoG = SO3View::EvaluateRp(t_corrected, spline_meta_.segments.at(0),
                              parameters, nullptr);
      v_inG = R3View::velocity(t_corrected,
                              spline_meta_.segments.at(0),
                              parameters + knot_num, nullptr);
    }

    LOG(ERROR) << "Interpolation velocity = " << v_inG.transpose() << std::endl;

    // LOG(ERROR) << "Pointer to linear_bias: " << parameters[2 * knot_num] << std::endl;
    Eigen::Map<Vec3d const> linear_bias(parameters[2 * knot_num]);          // 速度偏置
    

    // residuals[0] = weight_ * (doppler_ - pt_.normalized().transpose() * S_ItoG.matrix().inverse() * (v_inG + linear_bias).eval());

    Eigen::Vector3d corrected_velocity = v_inG + linear_bias;
    double doppler_actual = pt_.normalized().transpose() * S_ItoG.matrix().inverse() * corrected_velocity;
    residuals[0] = doppler_ - doppler_actual;
    residuals[0] *= weight_;


    debug_ceres.Open();
    if(!clear_debug)
    {
      clear_debug = true;
      debug_ceres.Close();

      debug_ceres.debug_file.open(debug_ceres.file_path, std::ios::trunc);
      // debug_ceres.debug_file.clear();
      debug_ceres.debug_file.close();

      debug_ceres.Open();
      debug_ceres.debug_file << "Start to Record \n";
    }

    debug_ceres_jacobis.Open();
    debug_ceres_jacobis.debug_file << "Evaluate DopplerFactor \n";

    // LOG(ERROR) << "open debug file: " << debug_ceres.file_path << std::endl;
    debug_ceres.debug_file << "residuals = " << std::setprecision(20) << residuals[0] << std::endl;
    // LOG(ERROR) << "residuals done" << std::endl;


    // debug
    Eigen::RowVectorXd pt_row_vec = pt_.transpose();

    // 打印pt_row_vec
    std::cout << "pt_row_vec = [";
    for (int i = 0; i < pt_row_vec.size(); ++i) {
        std::cout << pt_row_vec(i);  // 输出元素
        if (i < pt_row_vec.size() - 1) {
            std::cout << ", ";  // 在元素间添加逗号
        }
    }
    std::cout << "]" << std::endl;  // 结束输出


    Eigen::RowVectorXd linear_bias_row_vec = linear_bias.transpose();


    // std::cout << "linear_bias_row_vec = " << linear_bias_row_vec << std::endl;    

    // 调整一下输出格式
    // std::cout << "Details: weight_ = " << std::setprecision(2) << weight_ << std::endl;
    // std::cout << "Details: doppler_ =  " << std::setprecision(2) << doppler_ << std::endl;
    // std::cout << "Details: pt_ = [ " << pt_row_vec << std::endl;
    // std::cout << "Details: pt_.norm = [ " << pt_row_vec.normalized() << std::endl;
    // std::cout << "Details: nS_ItoG = [ " << S_ItoG.matrix().inverse() << std::endl;
    // std::cout << "Details: nv_inG = [ " << v_inG.transpose() << std::endl; 
    // std::cout << "Details: nlinear_bias = [ " << linear_bias_row_vec << std::endl;   

    // assert(parameters[2 * knot_num] != nullptr && "parameters[2 * knot_num] is nullptr");
    // debug_ceres.debug_file << "Details: weight_ = " << std::setprecision(5) << weight_ 
    debug_ceres.debug_file << "Details: weight_ = " <<  weight_;
    debug_ceres.debug_file << "\n pt_row_vec = [" <<  Output(pt_row_vec) << "] ";
                                debug_ceres.debug_file << "\n pt_row_vec.norm = [" <<  Output(pt_row_vec.normalized()) << "] "
                                  << "\nS_ItoG = [" << S_ItoG.matrix().inverse() << "] "
                                  << "\nv_inG = [" << v_inG.transpose() << "] " 
                                  << "\nlinear_bias = [" << Output(linear_bias_row_vec) << "] " << std::endl;

    LOG(ERROR) << "Velocity residuals = " << residuals[0] << std::endl;


    // debug
    // Eigen::RowVectorXd pt_row_vec_debug;
    // pt_row_vec_debug.setZero();
    // pt_row_vec_debug = pt_.transpose().eval();
    // debug_ceres.debug_file << "pt_ = " << pt_ << ", pt_.size = " << pt_.size() << std::endl; 
    // debug_ceres.debug_file << "pt_row_vec_debug = " << pt_row_vec_debug << std::endl;



    // 不评估雅可比就返回
    if (!jacobians) {
      LOG(ERROR) << "Doppler No Jacobians " << std::endl;
      debug_ceres.debug_file << "No Jacobians" << std::endl;
      debug_ceres.Close();
      
      return true;
    }
    else
    {
      LOG(ERROR) << " Calculate Jacobians " << std::endl;
    }

    // 位姿雅可比
    // Eigen::Matrix3d jac_lhs_R;
    Eigen::Vector3d jac_lhs_R;
    // jac_lhs_R = - weight_ * pt_.normalized().transpose() * S_ItoG.matrix().inverse() *  SO3::hat(v_inG + linear_bias);

    // jac_lhs_R =  - weight_ * (v_inG + linear_bias) * pt_.normalized().transpose();

    // jac_lhs_R =  - weight_ * (pt_.normalized().transpose().cross((v_inG + linear_bias))).transpose();
    jac_lhs_R = - weight_ * (pt_.normalized().cross((v_inG + linear_bias)));
    LOG(ERROR) << " jac_lhs_R = " << Output(jac_lhs_R) << std::endl;
    debug_ceres.debug_file << "jac_lhs_R" << " = [" << Output(jac_lhs_R) << "]\n";
    // debug_ceres.debug_file << "details = [" << jac_lhs_R.transpose() << "]\n";
   
    // 速度雅可比 J_v_d_
    Eigen::Vector3d J_v_d_ = - S_ItoG.matrix().inverse() * pt_.normalized();
    // 偏置雅可比 J_v_b_  
    Eigen::Vector3d J_v_b_ = - S_ItoG.matrix().inverse() * pt_.normalized();

    // LOG(ERROR) << "SplineOrder = " << SplineOrder << std::endl;

    LOG(ERROR) << " start to calculate Rotation control points " << std::endl;

    /// Rotation control point
    Eigen::Matrix<double, 4, 4> Jac_R;
    for (size_t i = 0; i < knot_num; i++) {

      size_t idx = i + J_R.start_idx;
      // LOG(ERROR) << " J_R.start_idx = " <<  J_R.start_idx << std::endl;
      // LOG(ERROR) << "idx = " << idx << std::endl;
      if (jacobians[idx]) {

        // for Debug
        // double* temp_test = jacobians[idx];
        // for(size_t j = 0;j < 12;j++)
        // {
        //   LOG(ERROR) << "j = " << j << std::endl;
        //   LOG(ERROR) << "jacobians[j] = " << temp_test[j] << std::endl;
        // }
      
        Eigen::Map<Eigen::Matrix<double, 1, 4, Eigen::RowMajor>> jac_kont_R(
            jacobians[idx]);
        jac_kont_R.setZero();
       
        jac_kont_R.block<1, 3>(0, 0) += (jac_lhs_R.transpose() * J_R.d_val_d_knot[i]).eval();

        LOG(ERROR) << " J_R.d_val_d_knot[ " << i << "]" << std::endl;

        debug_ceres.debug_file << "J_R.d_val_d_knot[" << i << "] = [" <<  Output_M(J_R.d_val_d_knot[i]) << "]\n";

        jac_kont_R *= weight_;

        Eigen::RowVectorXd jac_kont_R_copy = jac_kont_R;

        LOG(ERROR) << " J_R_[ " << i << "]" << std::endl;
        // debug_ceres.debug_file << "J_R_" << i << " = [" << jac_kont_R_copy.transpose() << "]\n";
        debug_ceres.debug_file << "J_R_" << i << " = [" << Output(jac_kont_R_copy) << "]\n";
      
        Jac_R.block<1,4>(i, 0) = jac_kont_R_copy;

        // debug_ceres_jacobis.debug_file << jac_kont_R_copy.transpose() << " ";
        debug_ceres_jacobis.debug_file << Output(jac_kont_R_copy) << " ";
      }
    }
    LOG(ERROR) << "Calculate Rotation Control Jacobbi " << std::endl;
    // LOG(ERROR) << "Jacobi for position J_v." << std::endl;
      // for (size_t i = 0; i < knot_num; ++i) {
      //     LOG(ERROR) << "Mat3[" << i << "] =\n" << J_v.d_val_d_knot[i] << "\n\n";
      // }

    LOG(ERROR) << " J_v_d_ = " << std::endl;
    debug_ceres.debug_file << "J_v_d_ = " << J_v_d_ << "\n";

    Eigen::Matrix<double, 4, 3> Jac_p;
    /// position control point
    for (size_t i = knot_num; i < 2 * knot_num; i++) {
      size_t idx = i;   // [0, knot_num - 1]
      // LOG(ERROR) << "idx = " << idx << std::endl;
      if (jacobians[idx]) {
        Eigen::Map<Eigen::Matrix<double, 1, 3, Eigen::RowMajor>> jac_kont_p(
            jacobians[idx]);
        jac_kont_p.setZero();
        
        double d_val_d_knot = J_v.d_val_d_knot[i - knot_num];
        Eigen::VectorXd temp_cal;
        // temp_cal.setZero();
        // temp_cal = (J_v_d_ * J_v.d_val_d_knot[i - knot_num]);
        temp_cal = (d_val_d_knot * J_v_d_);

        LOG(ERROR) << "J_v.d_val_d_knot[i - knot_num] = " << std::endl;
        double J_v_d_copy = J_v.d_val_d_knot[i - knot_num];
        LOG(ERROR) << "J_v.d_val_d_knot[i - knot_num] = " << J_v_d_copy << std::endl;
        debug_ceres.debug_file << "J_v.d_val_d_knot[i - knot_num] = " 
                              << J_v_d_copy << std::endl;


        // debug_ceres.debug_file << "temp_cal = [" << temp_cal << "]"
        //                        << std::endl;

        // debug_ceres.debug_file << "temp_cal = [" << J_v_d_ << "] "
        //                        << " * [" << J_v.d_val_d_knot[i - knot_num] << "]"
        //                        << " = 1: " << (J_v_d_ * J_v.d_val_d_knot[i - knot_num])
        //                        << "\n"
        //                        << " = 2: " << (J_v_d_ * J_v.d_val_d_knot[i - knot_num]).eval()
        //                        << std::endl;
        /// 1*1 1*3
        // jac_kont_p =  (J_v_d_ * J_v.d_val_d_knot[i - knot_num]).eval(); // TODO: i - knot_num 0-4 的范围
        jac_kont_p =  (J_v.d_val_d_knot[i - knot_num] * J_v_d_ ).eval(); // TODO: i - knot_num 0-4 的范围
        // jac_kont_p = (weight_ * jac_kont_p).eval();


        jac_kont_p *= weight_;

        Eigen::RowVectorXd jac_kont_p_copy; // = jac_kont_p;
        jac_kont_p_copy = jac_kont_p;
        // debug_ceres.debug_file << "J_p_" << i - knot_num << " = [" << jac_kont_p_copy.transpose() << "]\n";

        // LOG(ERROR) << "J_v_d_" << i - knot_num << " = \n[" << J_v_d_ << "]\n";
        LOG(ERROR) << "J_v_d_ " << std::endl;
        // debug_ceres.debug_file << "J_v_d_" << i - knot_num << " = [" << J_v_d_.transpose() << "]\n";
        debug_ceres.debug_file << "J_v_d_" << i - knot_num << " = [" << Output(J_v_d_) << "]\n";
        // debug_ceres.debug_file << "J_v_d_" << i - knot_num << " = \n[" << J_v_d_.transpose() << "]\n";
        LOG(ERROR) << "J_v_.d_val_d_knot_" << std::endl;
        // debug_ceres.debug_file << "J_v_.d_val_d_knot_" << i - knot_num << " = [" << (J_v.d_val_d_knot[i - knot_num]) << "]\n";
        debug_ceres.debug_file << "J_v_.d_val_d_knot_" << i - knot_num << " = [" << (J_v_d_copy) << "]\n";

        // Eigen::Matrix<double, 1, 3, Eigen::RowMajor> jac_kont_p_copy = jac_kont_p;
        // Eigen::VectorXd jac_kont_p_copy = jac_kont_p;
        // LOG(ERROR) << "J_p_" << i - knot_num << " = \n[" << jac_kont_p_copy << "]\n";
        // debug_ceres.debug_file << "J_p_" << i - knot_num << " = [" << jac_kont_p_copy.transpose() << "]\n";
        LOG(ERROR) << "J_p_" << i - knot_num << " = [" << std::endl;
        debug_ceres.debug_file << "J_p_" << i - knot_num << " = [" << Output(jac_kont_p_copy) << "]\n";

        Jac_p.block<1,3>(i - knot_num, 0) = jac_kont_p_copy;

        // debug_ceres_jacobis.debug_file << jac_kont_p_copy.transpose() << " ";
        LOG(ERROR) << "jac_kont_p_copy = " << " ";
        debug_ceres_jacobis.debug_file << Output(jac_kont_p_copy) << " ";
      }
    }

    LOG(ERROR) << "Calculate Position Control Jacobbi " << std::endl;

    // // DEBUG:
    // LOG(ERROR) << "Parameters.size = " << this->parameter_block_sizes().size() << std::endl;

    // // LOG(ERROR) << "Parameters.size = " << mutable_parameter_block_sizes().size() << std::endl;
    // LOG(ERROR) << "Search for = " << 2 * knot_num << std::endl;

    // for (int i = 0; i < this->parameter_block_sizes().size(); ++i) {
    //     LOG(ERROR) << "Block size at index " << i << " = " << parameter_block_sizes()[i];
    // }
    // // 使用所有的参数块
    // for (int i = 0; i < this->parameter_block_sizes().size(); ++i) {
    //     LOG(ERROR) << "Parameter " << i << " = " << parameters[i][0];
    // }
    // LOG(ERROR) << "Parameter for last = " << parameters[8][0] 
    // << ", " << parameters[8][1] 
    // << ", " << parameters[8][2] << std::endl;

    // for (size_t i = 0; i < this->parameter_block_sizes().size(); ++i) {
    //     if (jacobians[i] != nullptr) {
    //         LOG(ERROR) << "Jacobian at index " << i << " is valid.";
    //     } else {
    //         LOG(ERROR) << "Jacobian at index " << i << " is nullptr.";
    //     }
    // }

    // [3] velocity_bias 的雅可比
    Eigen::RowVectorXd J_velocity_bias_copy_;
    if(jacobians[2 * knot_num])
    {
      // Eigen::Map<Eigen::Matrix<double, 1, 3>> J_velocity_bias_(jacobians[2 * knot_num]);
       
      LOG(ERROR) << "J_velocity_bias_ = " << ((jacobians[2 * knot_num] == nullptr)? "nullptr": "exist") << std::endl;
      Eigen::Map<Eigen::Matrix<double, 1, 3, Eigen::RowMajor>> J_velocity_bias_(jacobians[2 * knot_num]);
      // LOG(ERROR) << "J_velocity_bias_ = " << J_velocity_bias_ << std::endl;

      // LOG(ERROR) << "J_velocity_rot_ after = " << ((jacobians[2 * knot_num - 1] == nullptr)? "nullptr": "exist") << std::endl;

      // J_velocity_bias_.setZero();
      // LOG(ERROR) << "J_v_b_ = " << J_v_b_.transpose() << std::endl;
      // J_velocity_bias_ = (J_v_b_.transpose()).eval();
      J_velocity_bias_ = J_v_b_.transpose().eval();
      // LOG(ERROR) << "J_v_b_ = " << jacobians[2 * knot_num][0] << ", " 
      //             << jacobians[2 * knot_num][1] << ", "
      //             << jacobians[2 * knot_num][2] << ", "<< std::endl;
      // LOG(ERROR) << "J_v_b_ = " << J_velocity_bias_ << std::endl;
      // LOG(ERROR) << "J_v_b_ = " << J_velocity_bias_ << std::endl;

      // Eigen::Matrix<double, 1, 3, Eigen::RowMajor> J_velocity_bias_copy_ = J_velocity_bias_;
      J_velocity_bias_copy_ = J_velocity_bias_;
      // LOG(ERROR) << "J_v_b_" << " = [\n" << J_velocity_bias_copy_ << "]\n";
      LOG(ERROR) << "J_velocity_bias_copy_";
      debug_ceres_jacobis.debug_file << Output(J_velocity_bias_copy_) << "]\n";
    }
    else
    {
      LOG(ERROR) << "No Calculate Velocity Bias Jacobbi " << std::endl;
    }

    LOG(ERROR) << "No Calculate Velocity Bias Jacobbi " << std::endl;

    // [4] timeoffset 本身无偏置,因此不用加入
    // Eigen::Map<Eigen::Matrix<double, 1, 3>> J_timeoffset_(jacobians[knot_num + 2]);
    // J_timeoffset_.setZero();
    // J_timeoffset_ = J_v_b_;    

    LOG(ERROR) << "DopplerFactor Evaluation Done" << std::endl;

    LOG(ERROR) << "All Jacobi for Doppler factor" << std::endl;
    debug_ceres.debug_file << "All Jacobi for Doppler factor " << std::endl;
    debug_ceres.debug_file << "Jac_R_ = " << Output_M(Jac_R) << std::endl;
    debug_ceres.debug_file << "J_p_ = " << Output_M(Jac_p) << std::endl;
    debug_ceres.debug_file << "J_velocity_bias_ = " << Output(J_velocity_bias_copy_) << std::endl;


    debug_ceres.debug_file << std::endl;
    debug_ceres.Close();


    debug_ceres_jacobis.Close();

    return true;
  }

private:
    int64_t time_ns_;
    Eigen::Vector3d pt_;
    SplineMeta<SplineOrder> spline_meta_;
    // Vec6d info_vec_;

    //TODO: gravity is not necessary
    // Eigen::Vector3d gravity;
    double doppler_;
    double weight_;

    // Eigen::Vector3d J_v_d_;
    // Eigen::Vector3d J_v_b_;
};



class EventAgularFactor : public ceres::CostFunction, SplitSpineView{
 public:
 EIGEN_MAKE_ALIGNED_OPERATOR_NEW
  using SO3View = So3SplineView;
  using R3View = RdSplineView;
  using SplitView = SplitSpineView;

  using Vec3d = Eigen::Matrix<double, 3, 1>;
  using Vec6d = Eigen::Matrix<double, 6, 1>;
  using Mat3d = Eigen::Matrix<double, 3, 3>;
  using Quatd = Eigen::Quaterniond;
  using SO3d = Sophus::SO3<double>;

  EventAgularFactor(int64_t time_ns, const cv::Point2d pt, const event_flow_velocity flow, 
            const Eigen::Vector3d doppler_velocity,
            const Eigen::Quaterniond & q_e_r, const Eigen::Vector3d& t_e_r,
            const SplineMeta<SplineOrder>& spline_segment_meta,
            double weight) // const Vec6d& info_vec)
      : time_ns_(time_ns),
        pt_(pt), doppler_velocity_(doppler_velocity),
        q_e_r(q_e_r), t_e_r(t_e_r),
        spline_meta_(spline_segment_meta),
        lock_extrincs(true),      // HAO TODO: 暂时不优化外参
        weight_(weight)

    // info_vec_(info_vec) 
    {
      set_num_residuals(1);           // 定义残差值的大小(事件角速度残差)

      flow_ << flow.x, flow.y, 0;

      size_t knot_num = this->spline_meta_.NumParameters();
      // LOG(ERROR) << "knot_num = " << knot_num << std::endl;

      // TODO: 需要提供采样曲线的多普勒速度和偏执                   
      for (size_t i = 0; i < knot_num; ++i) {             
        mutable_parameter_block_sizes()->push_back(4);   // rotation
      }
      for (size_t i = 0; i < knot_num; ++i) {
        mutable_parameter_block_sizes()->push_back(3);   // position
      }

      mutable_parameter_block_sizes()->push_back(3);    // omega bias
      
      // if(!optition.lock_extrincs)
      LOG(ERROR) << "lock extrincs? " << ((lock_extrincs)? "True": "False");
      if(! lock_extrincs)
      {
        mutable_parameter_block_sizes()->push_back(4);  // q_e_r
        mutable_parameter_block_sizes()->push_back(3);  // t_e_r
      }
      mutable_parameter_block_sizes()->push_back(1);  // time_offset 事件时间和雷达时间的偏移
    }

   virtual bool Evaluate(double const* const* parameters, double* residuals,
                        double** jacobians) const {
      typename SO3View::JacobianStruct J_R;
      typename SO3View::JacobianStruct J_w;
      typename R3View::JacobianStruct J_v;
      
      LOG(ERROR) << "Evaluate EventAgularFactor " << std::endl;

      debug_ceres.Open();
      debug_ceres.debug_file << "Evaluate EventAgularFactor \n";

      debug_ceres_jacobis.Open();
      debug_ceres_jacobis.debug_file << "Evaluate EventAgularFactor \n";

      debug_ceres_jacobis.debug_file << "[ ";

      size_t knot_num = spline_meta_.NumParameters();
      Eigen::Map<Vec3d const> omega_bias(parameters[2 * knot_num]);

      // Eigen::Map<Mat3d const> T_R_e_r(parameters[knot_num + 1]);
      // HAO TODO: 修改
      int t_offset_index = 2 * knot_num + 1;
      if(! lock_extrincs)
      {
        Eigen::Map<Quatd const> q_e_r(parameters[2 * knot_num + 1]);
        Eigen::Map<Vec3d const> T_t_e_r(parameters[2 * knot_num + 2]);
        t_offset_index = 2 * knot_num + 3;
      }

      double time_offset_in_ns = parameters[t_offset_index][0];

      LOG(ERROR) << "Correct time: " << time_offset_in_ns << std::endl;
      LOG(ERROR) << "Max Time: " << spline_meta_.segments.at(0).MaxTimeNs() << std::endl;
      LOG(ERROR) << "Min Time: " << spline_meta_.segments.at(0).MinTimeNs() << std::endl;
      

      int64_t t_corrected = time_ns_ + (int64_t)time_offset_in_ns;

      t_corrected = std::min(t_corrected, spline_meta_.segments.at(0).MaxTimeNs() - 1);
      t_corrected = std::max(t_corrected, spline_meta_.segments.at(0).MinTimeNs() + 1);

      LOG(ERROR) << "Interplate Event Flow " << std::endl;

      // 估计的速度 
      // Eigen::Vector3d gyro_, vel_, rot_accel, accel_r3;
      Eigen::Vector3d gyro_, rot_accel, v_inG;
      SO3d S_ItoG;
      if (jacobians){
        S_ItoG = SO3View::EvaluateRp(t_corrected, spline_meta_.segments.at(0),
                        parameters, &J_R);

        gyro_ = SO3View::VelocityBody(t_corrected,
                                            spline_meta_.segments.at(0),
                                            parameters, &J_w);

        rot_accel = SO3View::accelerationBody(t_corrected,  
                                              spline_meta_.segments.at(0), 
                                              parameters);

        v_inG = R3View::velocity(t_corrected,
                                      spline_meta_.segments.at(0),
                                      parameters + knot_num, &J_v);   

        // accel_r3 = R3View::acceleration(t_corrected,
        //                             spline_meta_.segments.at(0),
        //                             parameters + knot_num, nullptr);   // &J_a
      }else{
        S_ItoG = SO3View::EvaluateRp(t_corrected, spline_meta_.segments.at(0),
                        parameters, nullptr);
                               
        gyro_ = SO3View::VelocityBody(t_corrected,
                                      spline_meta_.segments.at(0),
                                      parameters, nullptr);

        rot_accel = SO3View::accelerationBody(t_corrected,  
                                      spline_meta_.segments.at(0), 
                                      parameters);
      
        v_inG = R3View::velocity(t_corrected,
                              spline_meta_.segments.at(0),
                              parameters + knot_num, nullptr);   

        // vel_ = R3View::velocity(t_corrected,
        //                               spline_meta_.segments.at(0),
        //                               parameters + knot_num, nullptr);

        // accel_r3 = R3View::acceleration(t_corrected,
        //                             spline_meta_.segments.at(0),
        //                             parameters + knot_num, nullptr);
      }

      LOG(ERROR) << "Set Jacobi Matrix " << std::endl;

      // // Conversion vel
      // Eigen::Matrix3d R_e_r = q_e_r.toRotationMatrix();   
      // Eigen::Vector3d pre_vec = Skew(pt_) * R_e_r * ((gyro_ + angular_bias).cross(t_e_r) + doppler_velocity_); // use it add tranpose()
      // Eigen::Vector3d post_vec = (flow_ +  Skew(pt_) * R_e_r * (gyro_ + angular_bias));

      
      // Conversion vel
      Eigen::Matrix3d R_e_r = q_e_r.toRotationMatrix();   
      Eigen::Vector3d pre_vec = Skew(pt_) * R_e_r * ((gyro_ + omega_bias).cross(t_e_r) + S_ItoG.matrix().inverse() * v_inG); // use it add tranpose()
      Eigen::Vector3d post_vec = (flow_ + Skew(pt_) * R_e_r * (gyro_ + omega_bias));


      // 残差计算
      residuals[0] =  weight_ * pre_vec.transpose() * post_vec;

      debug_ceres.debug_file << "residuals = " << std::setprecision(5) << residuals[0] << std::endl;
      LOG(ERROR) << "residuals done" << std::endl;


      // Eigen::RowVectorXd pt_row_vec = pt_.transpose();
      // Eigen::RowVectorXd gyro_row_vec = gyro_.transpose();
      Eigen::RowVectorXd omega_bias_row_vec = omega_bias.transpose();
      // LOG(ERROR) << "A" << std::endl;
      Eigen::RowVectorXd t_e_r_row_vec = t_e_r.transpose();
      // LOG(ERROR) << "B" << std::endl;
      // debug_ceres.debug_file << "Details: weight_ = " << std::setprecision(5) << weight_ 
      //                               << "\n Skew(pt_) = [" <<  Skew(pt_) << "] "
      //                               << "\n R_e_r = [" <<  R_e_r << "] "
      //                               << "\n gyro_ = [" <<  gyro_.transpose() << "] "
      //                               << "\n omega_bias = [" <<  omega_bias_row_vec << "] "
      //                               << "\n t_e_r = [" <<  t_e_r.transpose() << "] "
      //                               << "\nS_ItoG = [" << S_ItoG.matrix().inverse() << "] "
      //                               << "\nv_inG = [" << v_inG.transpose() << "] " << std::endl;
      // LOG(ERROR) << "start to output" << std::endl;
      // LOG(ERROR) << "Details: weight_ = " << std::setprecision(5) << weight_<< std::endl;
      // LOG(ERROR) << "Skew(pt_) = [" << std::setprecision(3) << Skew(pt_) << "] "<< std::endl;
      // LOG(ERROR) << "R_e_r = [" << std::setprecision(6) << R_e_r << "] "<< std::endl;
      // LOG(ERROR) << "gyro_ = [" << std::setprecision(4) << gyro_.transpose() << "] "<< std::endl;
      // LOG(ERROR) << "omega_bias = [" << std::setprecision(4) << omega_bias_row_vec << "] "<< std::endl;
      // LOG(ERROR) << "t_e_r = [" << std::setprecision(2) << t_e_r_row_vec << "] "<< std::endl;
      // LOG(ERROR) << "S_ItoG = [" << std::setprecision(3) << S_ItoG.matrix().inverse() << "] "<< std::endl;
      // LOG(ERROR) << "v_inG = [" << std::setprecision(4) << v_inG.transpose() << "] " << std::endl;


      debug_ceres.debug_file << "Details: weight_ = " << weight_ 
                                    << "\n Skew(pt_) = [" <<  Skew(pt_) << "] "
                                    << "\n R_e_r = [" <<  R_e_r << "] "
                                    << "\n gyro_ = [" <<  gyro_.transpose() << "] "
                                    << "\n omega_bias = [" <<  Output(omega_bias_row_vec) << "] "
                                    << "\n t_e_r = [" <<  Output(t_e_r_row_vec) << "] "
                                    << "\nS_ItoG = [" << S_ItoG.matrix().inverse() << "] "
                                    << "\nv_inG = [" << v_inG.transpose() << "] " << std::endl;

      debug_ceres.debug_file << "pre_vec = " <<  pre_vec.transpose() << std::endl;
      debug_ceres.debug_file << "post_vec = " <<  post_vec.transpose() << std::endl;
      
      LOG(ERROR) << "Angular Residual = " << residuals[0] << std::endl;

      

      // 不评估雅可比就返回
      if (!jacobians) {
        LOG(ERROR) << "EventAgularFactor No Jacobi!" << std::endl;
        debug_ceres.Close();

        debug_ceres_jacobis.Close();
        return true;
      }

      // TODO: 补充雅可比
      // if (jacobians) {
          // [1] gyro_ 的雅可比
          Eigen::Matrix3d J_gyro_pre_ = (Skew(pt_) * R_e_r * Skew(t_e_r));
          Eigen::Matrix3d J_gyro_post_ = Skew(pt_) * R_e_r;
          LOG(ERROR) << "Calculate gyro Jacobbi " << std::endl;

          debug_ceres.debug_file << "J_gyro_pre_ = " <<  J_gyro_pre_ << std::endl;
          debug_ceres.debug_file << "J_gyro_post_ = " <<  J_gyro_post_ << std::endl;

          // [2] S_ItoG 的雅可比
          Eigen::Matrix3d J_S_pre_ = - Skew(pt_) * R_e_r * S_ItoG.matrix().inverse() * SO3d::hat(v_inG);
          debug_ceres.debug_file << "J_S_pre_ = " <<  J_S_pre_ << std::endl;

          LOG(ERROR) << "Calculate S_ItoG Jacobbi " << std::endl;

          ///[step1-2] jacobians of control points
          /// Rotation control point
          Eigen::Matrix4d Jac_R;
          for (size_t i = 0; i < knot_num; i++) {
            size_t idx = i;
            if (jacobians[idx]) {
              Eigen::Map<Eigen::Matrix<double, 1, 4, Eigen::RowMajor>> jac_kont_R(
                  jacobians[idx]);
              jac_kont_R.setZero();

              /// 1*3 3*3
              jac_kont_R.block<1, 3>(0, 0) =
                  (J_gyro_pre_.transpose() * J_w.d_val_d_knot[i] * post_vec).transpose()
                  + pre_vec.transpose() * J_gyro_post_ * J_w.d_val_d_knot[i] + (J_S_pre_.transpose() * post_vec).transpose();
              jac_kont_R = (weight_ * jac_kont_R); // .eval();

              Eigen::VectorXd jac_kont_R_copy = jac_kont_R;

              debug_ceres.debug_file << "J_w.d_val_d_knot[" << i << "] = [" << J_w.d_val_d_knot[i] << "]\n";
              debug_ceres.debug_file << "jac_lhs_R_" << i << " = [" << jac_kont_R_copy.transpose() << "]\n";

              Jac_R.block<1,4>(i,0) = jac_kont_R_copy.transpose();

              // Special for Jacobias
              debug_ceres_jacobis.debug_file << jac_kont_R_copy.transpose() << " ";
            }
          }
          LOG(ERROR) << "Add jacobians for Rotation control point " << std::endl;

          // [3] velocity 的雅可比
          // Eigen::Map<Eigen::Matrix<double, 1, 3>> J_vel_(jacobians[knot_num]);
          Eigen::Matrix3d J_vel_ = Skew(pt_) * R_e_r * S_ItoG.matrix().inverse();
          LOG(ERROR) << "Calculate velocity Jacobbi " << std::endl;
          debug_ceres.debug_file << "J_vel_ = [" << J_vel_ << "]\n";

          /// position control point
          Eigen::Matrix<double, 4, 3> Jac_p;
          for (size_t i = knot_num; i <  2 * knot_num; i++) {
            size_t idx = i;
            if (jacobians[idx]) {
              Eigen::Map<Eigen::Matrix<double, 1, 3, Eigen::RowMajor>> jac_kont_p(
                  jacobians[idx]);
              jac_kont_p.setZero();

              /// 1*1 1*3
              jac_kont_p = J_v.d_val_d_knot[i - knot_num] * J_vel_.transpose() * post_vec;
              jac_kont_p = (weight_ * jac_kont_p); // .eval();


              Eigen::VectorXd jac_kont_p_copy = jac_kont_p;
              debug_ceres.debug_file << "J_v.d_val_d_knot[" << i - knot_num << "] = [" <<  J_v.d_val_d_knot[i - knot_num] << "]\n";
              debug_ceres.debug_file << "jac_kont_p_" << i - knot_num << " = [" << Output(jac_kont_p_copy) << "]\n";
              // debug_ceres.debug_file << "jac_kont_p_" << i - knot_num << " = [" << jac_kont_p_copy.transpose() << "]\n";

              Jac_p.block<1, 3>(i - knot_num, 0) = jac_kont_p_copy.transpose();

              // Special for Jacobias
              // debug_ceres_jacobis.debug_file << jac_kont_p_copy.transpose() << " ";
            }
          }
          LOG(ERROR) << "Add jacobians for Position control point " << std::endl;


          // Debug Residual & Jacobi
          // for (int i = 0; i < this->parameter_block_sizes().size(); ++i) {
          //     LOG(ERROR) << "Block size at index " << i << " = " << parameter_block_sizes()[i];
          // }
          // // 使用所有的参数块
          // for (int i = 0; i < this->parameter_block_sizes().size(); ++i) {
          //     LOG(ERROR) << "Parameter " << i << " = " << parameters[i][0];
          // }
          // LOG(ERROR) << "Parameter for last = " << parameters[8][0] 
          // << ", " << parameters[8][1] 
          // << ", " << parameters[8][2] << std::endl;

          // for (size_t i = 0; i < this->parameter_block_sizes().size(); ++i) {
          //     if (jacobians[i] != nullptr) {
          //         LOG(ERROR) << "Jacobian at index " << i << " is valid.";
          //     } else {
          //         LOG(ERROR) << "Jacobian at index " << i << " is nullptr.";
          //     }
          // }

          // [3] angular_bias 的雅可比
          Eigen::RowVectorXd Jac_w_bias;
          if(jacobians[2 * knot_num])
          {
            Eigen::Map<Eigen::Matrix<double, 1, 3>> J_angular_bias_(jacobians[2 * knot_num]);
            J_angular_bias_.setZero();
            J_angular_bias_ = (J_gyro_pre_.transpose() * post_vec).transpose() + pre_vec.transpose() * Skew(pt_) * R_e_r;

            // Eigen::VectorXd J_angular_bias_copy = J_angular_bias_;
            // Jac_w_bias = J_angular_bias_copy.transpose();


            Jac_w_bias = J_angular_bias_.eval();
            debug_ceres.debug_file << "J_angular_bias_ = " << Output(Jac_w_bias) << "]\n";

            // debug_ceres.debug_file << "J_angular_bias_ = " << Output(J_angular_bias_copy) << "]\n";

            // Special for Jacobias
            // debug_ceres_jacobis.debug_file << Jac_w_bias << " ";
          }
          LOG(ERROR) << "Add jacobians for Angular Bias" << std::endl;

          // if(!optition.lock_extrincs)
          // {
              // 雅可比矩阵
              // Eigen::Matrix<double, 1, 4> J;

          // 对于旋转部分的雅可比
          /* 推导过程
          residuals[0] = (Skew(pt_) * R_e_r * (gyro_.cross(t_e_r) + vel_)).transpose() * 
                              (flow_ - Skew(pt_) * R_e_r * (gyro_ + angular_bias))
          A = (Skew(pt_) * R_e_r * (gyro_.cross(t_e_r) + vel_)).transpose()
          B = (flow_ - Skew(pt_) * R_e_r * (gyro_ + angular_bias))
          dA = Skew(pt_) * dR_theta * R_e_r * (gyro_.cross(t_e_r) + vel_)).transpose()
          dA.transpose() = Skew(pt_) * dR_theta * R_e_r * (gyro_.cross(t_e_r) + vel_))

          residuals[0] / R_e_r = ???
          */
          // if(!optition.lock_extrincs)

          LOG(ERROR) << "lock_extrincs: " << ((lock_extrincs)? "True":"False") << std::endl;
          // int t_offset_index = 2 * knot_num + 1;
          if(!lock_extrincs)
          {
            if(jacobians[2 * knot_num + 1] && jacobians[2 * knot_num + 2])
            {
              Eigen::Map<Eigen::Matrix<double, 1, 3>> J_R(jacobians[2 * knot_num + 1]);
              Eigen::Map<Eigen::Matrix<double, 1, 3>> J_t(jacobians[2 * knot_num + 2]);
              Eigen::MatrixXd J_pre_R = - (Skew(pt_) * Skew(R_e_r * ((gyro_ + omega_bias).cross(t_e_r) + doppler_velocity_))).transpose();
              
              Eigen::MatrixXd J_pre_t = - (Skew(pt_) * R_e_r * Skew(gyro_ + omega_bias)).transpose();

              Eigen::MatrixXd J_post_R = - (Skew(pt_) * Skew(R_e_r * ((gyro_ + omega_bias).cross(t_e_r) + doppler_velocity_)));

              // debug_ceres.debug_file << "J_pre_R = " << J_pre_R << "]\n";
              // debug_ceres.debug_file << "J_pre_t = " << J_pre_t << "]\n";
              // debug_ceres.debug_file << "J_post_R = " << J_post_R << "]\n";

              debug_ceres.debug_file << "J_pre_R = " << Output_M(J_pre_R) << "]\n";
              debug_ceres.debug_file << "J_pre_t = " << Output_M(J_pre_t) << "]\n";
              debug_ceres.debug_file << "J_post_R = " << Output_M(J_post_R) << "]\n";

              J_R = (J_pre_R * post_vec + pre_vec * J_post_R).transpose();
              J_t = (J_pre_t * post_vec).transpose();

              Eigen::VectorXd J_R_copy = J_R;
              Eigen::VectorXd J_t_copy = J_t;

              // debug_ceres.debug_file << "J_R = " << J_R_copy << "]\n";
              // debug_ceres.debug_file << "J_t = " << J_t_copy << "]\n";

              debug_ceres.debug_file << "J_R = " << Output(J_R_copy) << "]\n";
              debug_ceres.debug_file << "J_t = " << Output(J_t_copy) << "]\n";

              // 如果优化 extrincs,那么Jacobi需要重新对应
              t_offset_index =  2 * knot_num + 3;
            }
          }

          /*
            Eigen::Matrix3d R_e_r = q_e_r.toRotationMatrix();   
            Eigen::Vector3d pre_vec = Skew(pt_) * R_e_r * ((gyro_ + rot_accel * t_e_r + angular_bias).cross(t_e_r) + S_ItoG.matrix().inverse() * v_inG); // use it add tranpose()
            Eigen::Vector3d post_vec = (flow_ +  Skew(pt_) * R_e_r * (gyro_ + rot_accel * t_e_r + angular_bias));
            double residual = pre_vec.transpose() * post_vec
          */

          // 添加时移优化
          // Eigen::RowVectorXd Jac_t;
          double Jac_t;
          if(jacobians[t_offset_index])
          {
            // 这个雅可比是标量
            // Eigen::Map<Eigen::Matrix<double, 1, 3, Eigen::RowMajor>> J_t_offset(jacobians[t_offset_index], 3);  // Assuming a 3D vector
             
            // J_t_offset.setZero();

            Eigen::Map<Eigen::Matrix<double, 1, 1, Eigen::RowMajor>> J_t_vec(jacobians[t_offset_index]);
            // Eigen::VectorXd 
            J_t_vec = ((Skew(pt_) * R_e_r * t_e_r.cross(rot_accel)).transpose() * post_vec)
                          + pre_vec.transpose() * (Skew(pt_) * R_e_r * rot_accel);
            J_t_vec *= (1e-9 * weight_);


            // Eigen::VectorXd J_t_vec_copy = J_t_vec;
            // debug_ceres.debug_file << "J_t_vec = " << J_t_vec_copy << "]\n";
            // Jac_t = J_t_vec_copy.transpose();

            // Jac_t = J_t_vec.transpose().eval();

            Jac_t = J_t_vec(0, 0).eval();

            // debug_ceres_jacobis.debug_file << Output(Jac_t) << "]\n";

            // double J_t_offset = J_t_vec.eval();
            // J_t_offset *= 1e-9 * weight_;
            // jacobians[t_offset_index][0] = J_t_offset;
          }

          LOG(ERROR) << "Add jacobians for J_t_offset" << std::endl;

      // }

      LOG(ERROR) << "All Jacobi for Event factor" << std::endl;
      debug_ceres.debug_file << "All Jacobi for Event factor" << std::endl;
      debug_ceres.debug_file << "Jac_R_ = " << Output_M(Jac_R) << std::endl;
      debug_ceres.debug_file << "Jac_p_ = " << Output_M(Jac_p) << std::endl;
      debug_ceres.debug_file << "Jac_angular_bias_ = " << Output(Jac_w_bias) << std::endl;
      // debug_ceres.debug_file << "Jac_t = " << Output(Jac_t) << std::endl;
      debug_ceres.debug_file << "Jac_t = " << Output_double(Jac_t) << std::endl;

      // debug_ceres.debug_file << std::endl;
      debug_ceres.Close();
      debug_ceres_jacobis.Close();

      LOG(ERROR) << "All Jacobi for Event factor Done" << std::endl;

      return true;
    }

private:
    int64_t time_ns_;
    cv::Point2d pt_;
    Eigen::Vector3d flow_;
    Eigen::Vector3d doppler_velocity_;
    Eigen::Quaterniond q_e_r;
    Eigen::Vector3d t_e_r;
    SplineMeta<SplineOrder> spline_meta_;
    // Vec6d info_vec_;
    Eigen::Vector3d angular_bias;
    Eigen::Vector3d gravity;
    bool lock_extrincs;
    double weight_;
};


// bias_gyr_i, bias_gyr_j, bias_acc_i, bias_acc_j
class NewBiasFactor : public ceres::SizedCostFunction<6, 3, 3, 3, 3> {
 public:
 EIGEN_MAKE_ALIGNED_OPERATOR_NEW
  NewBiasFactor(double dt, const Eigen::Matrix<double, 6, 1>& sqrt_info) {
    double sqrt_dt = std::sqrt(dt);
    sqrt_info_.setZero();
    sqrt_info_.diagonal() = sqrt_info / sqrt_dt;
  }
  virtual bool Evaluate(double const* const* parameters, double* residuals,
                        double** jacobians) const {
    using Vec3d = Eigen::Matrix<double, 3, 1>;
    using Vec6d = Eigen::Matrix<double, 6, 1>;

    LOG(ERROR) << "Evaluate Bias Factor " << std::endl;


    // Check the sizes match.
    const std::vector<int>& parameter_block_sizes_temp =
          this->parameter_block_sizes();
    LOG(ERROR) << "parameters need have " << (parameter_block_sizes_temp).size() <<std::endl;
    for(auto& param_block_size: parameter_block_sizes_temp)
    {
      LOG(ERROR) << "parameter size = " << param_block_size <<std::endl;
    }

    if(parameters == nullptr)
    {
      LOG(ERROR) << "parameters not exist " << std::endl;
      return false;
    }
    else
    {
      LOG(ERROR) << "parameters exist " << std::endl;
    }

    if(parameters[0] != nullptr)
      LOG(ERROR) << " parameters[0] exist " << std::endl;
    else
      LOG(ERROR) << " parameters[0] not exist " << std::endl;

    Eigen::Map<Vec3d const> bias_w_i(parameters[0]);
    Eigen::Map<Vec3d const> bias_w_j(parameters[1]);
    Eigen::Map<Vec3d const> bias_v_i(parameters[2]);
    Eigen::Map<Vec3d const> bias_v_j(parameters[3]);

    LOG(ERROR) << "Get All Bias Parameters " << std::endl;

    LOG(ERROR) << "bias_w_i: " << bias_w_i;
    LOG(ERROR) << "bias_w_j: " << bias_w_j;
    LOG(ERROR) << "bias_v_i: " << bias_v_i;
    LOG(ERROR) << "bias_v_j: " << bias_v_j;
    LOG(ERROR) << "bias_w_j - bias_w_i: " << (bias_w_j - bias_w_i);
    LOG(ERROR) << "bias_v_j - bias_v_i: " << (bias_v_j - bias_v_i);


    Vec6d res;
    res.block<3, 1>(0, 0) = bias_w_j - bias_w_i;
    res.block<3, 1>(3, 0) = bias_v_j - bias_v_i;

    Eigen::Map<Vec6d> residual(residuals);


    debug_ceres.Open();
    debug_ceres_jacobis.Open();
    if(!clear_debug)
    {
      clear_debug = true;
      debug_ceres.Close();

      debug_ceres.debug_file.open(debug_ceres.file_path, std::ios::trunc);
      // debug_ceres.debug_file.clear();
      debug_ceres.debug_file.close();

      debug_ceres.Open();
      debug_ceres.debug_file << "Start to Record \n";
    }
    debug_ceres.debug_file << "Evaluate BiasFactor \n";

    debug_ceres_jacobis.debug_file << "Evaluate BiasFactor \n";
    debug_ceres_jacobis.debug_file << "[ ";

    // LOG(ERROR) << "open debug file: " << debug_ceres.file_path << std::endl;

    Vec6d residual_vec = residual;
    debug_ceres.debug_file << "residuals = " << std::setprecision(5) << residual_vec.transpose() << std::endl;
    LOG(ERROR) << "residuals done" << std::endl;

    Eigen::RowVectorXd bias_w_i_row_vec = bias_w_i.transpose();
    Eigen::RowVectorXd bias_w_j_row_vec = bias_w_j.transpose();
    Eigen::RowVectorXd bias_v_i_row_vec = bias_v_i.transpose();
    Eigen::RowVectorXd bias_v_j_row_vec = bias_v_j.transpose();
    debug_ceres.debug_file << "Details: weight_ = " << std::setprecision(5)
                                  << "\n bias_w_i = [" <<  Output(bias_w_i_row_vec) << "] "
                                  << "\n bias_w_j = [" <<  Output(bias_w_j_row_vec) << "] "
                                  << "\n bias_v_i = [" <<  Output(bias_v_i_row_vec) << "] "
                                  << "\n bias_v_j = [" <<  Output(bias_v_j_row_vec) << "] "
                                   << "\n sqrt_info_ = [" <<  sqrt_info_ << std::endl;

                                

    LOG(ERROR) << "sqrt_info_ = \n" << sqrt_info_ << std::endl;
    LOG(ERROR) << "res = " << res << std::endl;

    residual = sqrt_info_ * res;
    // + Vec6d::Constant(10); // HAO TODO: Test residual of bias if too small

    LOG(ERROR) << "residual = " << residual.transpose() << std::endl;


    // // Debug: Residual & Jacobi
    // for (int i = 0; i < this->parameter_block_sizes().size(); ++i) {
    //     LOG(ERROR) << "Block size at index " << i << " = " << parameter_block_sizes()[i];
    // }
    // // 使用所有的参数块
    // for (int i = 0; i < this->parameter_block_sizes().size(); ++i) {
    //     LOG(ERROR) << "Parameter " << i << " = " << parameters[i][0];
    // }
    // LOG(ERROR) << "Parameter for last = " << parameters[8][0] 
    // << ", " << parameters[8][1] s
    // << ", " << parameters[8][2] << std::endl;



    if (jacobians) {

      for (size_t i = 0; i < this->parameter_block_sizes().size(); ++i) {
          if (jacobians[i] != nullptr) {
              LOG(ERROR) << "Jacobian at index " << i << " is valid.";
          } else {
              LOG(ERROR) << "Jacobian at index " << i << " is nullptr.";
          }
      }

      if (jacobians[0]) {
        Eigen::Map<Eigen::Matrix<double, 6, 3, Eigen::RowMajor>> jac_bg_i(
            jacobians[0]);
        jac_bg_i.setZero();
        jac_bg_i.block<3, 3>(0, 0) = -Eigen::Matrix3d::Identity();
        jac_bg_i.applyOnTheLeft(sqrt_info_);


        Eigen::MatrixXd jac_bg_i_copy = jac_bg_i;
        debug_ceres.debug_file << "J_bg_i = " << jac_bg_i_copy << "]\n";


        debug_ceres_jacobis.debug_file << jac_bg_i_copy << " ";
      }
      if (jacobians[1]) {
        Eigen::Map<Eigen::Matrix<double, 6, 3, Eigen::RowMajor>> jac_bg_j(
            jacobians[1]);
        jac_bg_j.setZero();
        jac_bg_j.block<3, 3>(0, 0) = Eigen::Matrix3d::Identity();
        jac_bg_j.applyOnTheLeft(sqrt_info_);

        Eigen::MatrixXd jac_bg_j_copy = jac_bg_j;
        debug_ceres.debug_file << "J_bg_j = " << jac_bg_j_copy << "]\n";

        debug_ceres_jacobis.debug_file << jac_bg_j_copy << " ";
      }
      if (jacobians[2]) {
        Eigen::Map<Eigen::Matrix<double, 6, 3, Eigen::RowMajor>> jac_ba_i(
            jacobians[2]);
        jac_ba_i.setZero();
        jac_ba_i.block<3, 3>(3, 0) = -Eigen::Matrix3d::Identity();
        jac_ba_i.applyOnTheLeft(sqrt_info_);

        Eigen::MatrixXd jac_ba_i_copy = jac_ba_i;
        debug_ceres.debug_file << "J_ba_i = " << jac_ba_i_copy << "]\n";

        debug_ceres_jacobis.debug_file << jac_ba_i_copy << " ";
      }
      if (jacobians[3]) {
        Eigen::Map<Eigen::Matrix<double, 6, 3, Eigen::RowMajor>> jac_ba_j(
            jacobians[3]);
        jac_ba_j.setZero();
        jac_ba_j.block<3, 3>(3, 0) = Eigen::Matrix3d::Identity();
        jac_ba_j.applyOnTheLeft(sqrt_info_);

        Eigen::MatrixXd jac_ba_j_copy = jac_ba_j;
        debug_ceres.debug_file << "J_ba_j = " << jac_ba_j_copy << "]\n";

        debug_ceres_jacobis.debug_file << jac_ba_j_copy << "]\n";
      }
    }
    else
    {
      LOG(ERROR) << "Jacobi is not exist " << std::endl; 
    }

    debug_ceres.Close();


    debug_ceres_jacobis.Close();
    return true;
  }

 private:
  Eigen::Vector3d acc_i_, acc_j_;
  Eigen::Vector3d gyr_i_, gyr_j_;
  Eigen::Matrix<double, 6, 6> sqrt_info_;
};
